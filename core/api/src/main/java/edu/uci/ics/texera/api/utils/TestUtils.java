package edu.uci.ics.texera.api.utils;

import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import edu.uci.ics.texera.api.constants.SchemaConstants;
import edu.uci.ics.texera.api.exception.TexeraException;
import edu.uci.ics.texera.api.tuple.Tuple;
import junit.framework.Assert;

/**
 * @author sandeepreddy602
 * @author Zuozhi Wang
 * @author rajeshyarlagadda
 * @author Bhushan Pagariya (bhushanpagariya)
 */
public class TestUtils {
	
    /**
     * Returns the default parent index path for all test case tables.
     * The test tables are highly recommended to be created under this directory.
     * 
     * @return
     */
	public static Path getDefaultTestIndex() {
		return Utils.getDefaultIndexDirectory().resolve("test_tables");
	}

    /**
     * Returns true if the tupleList contains a tuple.
     * 
     * Since we only want to compare the content of two tuples, _ID and PAYLOAD are two fields 
     *   that can be safely ignored because these two fields are automatically generated by the system.
     * 
     * @param tupleList
     * @param containsTuple
     * @return
     */
    public static boolean contains(List<Tuple> tupleList, Tuple containsTuple) {
        tupleList = Tuple.Builder.removeIfExists(tupleList, SchemaConstants._ID, SchemaConstants.PAYLOAD);
        containsTuple = new Tuple.Builder(containsTuple)
                .removeIfExists(SchemaConstants._ID, SchemaConstants.PAYLOAD).build();
                
        return tupleList.contains(containsTuple);
    }
    
    /**
     * Returns true if the tupleList contains a list of tuples.
     * 
     * Since we only want to compare the content of two tuples, _ID and PAYLOAD are two fields 
     *   that can be safely ignored because these two fields are automatically generated by the system.
     * 
     * @param tupleList
     * @param containsTupleList
     * @return
     */
    public static boolean containsAll(List<Tuple> tupleList, List<Tuple> containsTupleList) {
        tupleList = Tuple.Builder.removeIfExists(tupleList, SchemaConstants._ID, SchemaConstants.PAYLOAD);
        containsTupleList = Tuple.Builder.removeIfExists(containsTupleList, SchemaConstants._ID, SchemaConstants.PAYLOAD);
        
        return tupleList.containsAll(containsTupleList);
    }
    
    /**
     * Returns true if the two tuple lists are equivalent (order doesn't matter)
     * 
     * Since we only want to compare the content of two tuples, _ID and PAYLOAD are two fields 
     *   that can be safely ignored because these two fields are automatically generated by the system.
     * 
     * @param expectedResults
     * @param exactResults
     * @return
     */
    public static boolean equals(List<Tuple> expectedResults, List<Tuple> exactResults) {
        expectedResults = Tuple.Builder.removeIfExists(expectedResults, SchemaConstants._ID, SchemaConstants.PAYLOAD);
        exactResults = Tuple.Builder.removeIfExists(exactResults, SchemaConstants._ID, SchemaConstants.PAYLOAD);

        if (expectedResults.size() != exactResults.size())
            return false;
        
        return expectedResults.containsAll(exactResults) && exactResults.containsAll(expectedResults);
    }

    /**
     * Compare two tuple lists for given attribute values
     * 
     * @param expectedResults
     * @param exactResults
     * @param attributeNames
     * @return True if two tuples have same values for given attribute, otherwise false
     */
    public static boolean attributeEquals(List<Tuple> expectedResults, List<Tuple> exactResults, List<String> attributeNames) {
        if(expectedResults.size() != exactResults.size())
            return false;
        if(exactResults.size() == 0)
            return true;
        
        
        // Remove all unwanted attributes from expectedResults
        List<String> expectedResultAttrs = new ArrayList<>(expectedResults.get(0).getSchema().getAttributeNames());
        expectedResultAttrs.removeAll(attributeNames);
        String[] expectedResultsArr = expectedResultAttrs.toArray(new String[expectedResultAttrs.size()]);
        expectedResults = Tuple.Builder.removeIfExists(expectedResults, expectedResultsArr);

        // Remove all unwanted attributes from exactResults
        List<String> exactResultAttrs = new ArrayList<>(exactResults.get(0).getSchema().getAttributeNames());
        exactResultAttrs.removeAll(attributeNames);
        String[] exactResultsArr = exactResultAttrs.toArray(new String[exactResultAttrs.size()]);
        exactResults = Tuple.Builder.removeIfExists(exactResults, exactResultsArr);

        // 2-way comparision between expectedResults and exactResults
        return expectedResults.containsAll(exactResults) && exactResults.containsAll(expectedResults);
    }

    public static JsonNode testJsonSerialization(Object object) {
        return testJsonSerialization(object, false);
    }
    
    public static JsonNode testJsonSerialization(Object object, boolean printResults) {
        try {
            ObjectMapper objectMapper = new ObjectMapper();
            String json = objectMapper.writeValueAsString(object);
            Object resultObject = objectMapper.readValue(json, object.getClass());
            String resultJson = objectMapper.writeValueAsString(resultObject);
            
            JsonNode jsonNode = objectMapper.readValue(json, JsonNode.class);
            JsonNode resultJsonNode = objectMapper.readValue(resultJson, JsonNode.class);
            
            if (printResults) {
                System.out.println(resultJson);
            }
            
            Assert.assertEquals(object, resultObject);
            Assert.assertEquals(jsonNode, resultJsonNode);
            return jsonNode;
        } catch (IOException e) {
            throw new TexeraException(e);
        }
    }
    
}
